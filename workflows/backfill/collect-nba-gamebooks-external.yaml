# workflows/backfill/collect-nba-gamebooks-external-schedule.yaml
# Purpose: Collect NBA gamebook PDFs using external schedule extraction
# MUCH cleaner approach - follows existing scraper patterns

main:
  steps:
    - init:
        assign:
          - current_timestamp: ${sys.now()}
          - workflow_start: ${sys.now()}
          - execution_id: ${sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID")}
          - cloud_run_url: "https://nba-scrapers-756957797294.us-west2.run.app"
          - successful_games: 0
          - failed_games: 0
          - total_games_processed: 0
          - failed_game_codes: []
          
          # Configuration
          - pdf_version: "short"  # Start with short version for Phase 2A
          - season: 2023  # 2023-24 season
          
          # Test dates (expand after validation)
          - test_dates: [
              "2024-04-10",
              "2024-04-11", 
              "2024-04-12"
            ]
          
          # Pre-extracted game data (from schedule JSON)
          # In practice, this would be populated by calling the extractor script
          # or reading from a file generated by the extractor
          - games_to_process: [
              {
                "date": "2024-04-10",
                "game_code": "20240410/MEMCLE",
                "away_team": "MEM",
                "home_team": "CLE",
                "matchup": "MEM@CLE",
                "completed": true
              },
              {
                "date": "2024-04-11",
                "game_code": "20240411/LALGDCLE",
                "away_team": "LAL",
                "home_team": "CLE", 
                "matchup": "LAL@CLE",
                "completed": true
              }
            ]
          
    - log_start:
        call: sys.log
        args:
          text: "Starting NBA gamebooks collection using external schedule data (Phase 2A)"
          severity: INFO

    # Optional: Call external script to extract games (commented for now)
    # - extract_games_from_schedule:
    #     call: http.post
    #     args:
    #       url: ${cloud_run_url + "/extract-schedule-games"}
    #       body:
    #         season: ${season}
    #         dates: ${test_dates}
    #     result: extracted_games
    
    - log_games_to_process:
        call: sys.log
        args:
          text: ${"Found " + string(len(games_to_process)) + " games to process"}
          severity: INFO

    # Process each game individually (MUCH cleaner!)
    - process_individual_games:
        for:
          value: game
          in: ${games_to_process}
        steps:
          - log_processing_game:
              call: sys.log
              args:
                text: ${"üèÄ Processing " + game.matchup + " (" + game.game_code + ")"}
                severity: INFO
          
          # Skip if not completed (for backfill)
          - check_game_completed:
              if: ${not game.completed}
              then:
                steps:
                  - log_skipping_incomplete:
                      call: sys.log
                      args:
                        text: ${"Skipping incomplete game: " + game.game_code}
                        severity: INFO
                next: continue
          
          # Call the single-game scraper (clean and simple!)
          - process_gamebook:
              try:
                call: http.post
                args:
                  url: ${cloud_run_url + "/scrape"}
                  headers:
                    Content-Type: "application/json"
                  body:
                    scraper: "nbac_gamebook_pdf"
                    date: ${game.date}
                    game_code: ${game.game_code}
                    away_team: ${game.away_team}
                    home_team: ${game.home_team}
                    version: ${pdf_version}
                    group: "prod"
                  timeout: 300  # PDFs + parsing can take time
                result: gamebook_response
              except:
                as: e
                steps:
                  - log_gamebook_failure:
                      call: sys.log
                      args:
                        text: ${"‚ùå Failed to process " + game.game_code + ": " + e.message}
                        severity: WARNING
                  - increment_failed:
                      assign:
                        - failed_games: ${failed_games + 1}
                        - failed_game_codes: ${list.concat(failed_game_codes, [game.game_code])}
                next: continue
          
          # Check results
          - check_gamebook_success:
              switch:
                - condition: ${gamebook_response.code == 200 AND gamebook_response.body.status == "success"}
                  steps:
                    - increment_success:
                        assign:
                          - successful_games: ${successful_games + 1}
                    - extract_player_counts:
                        assign:
                          - active_players: ${gamebook_response.body.data.active_players}
                          - inactive_players: ${gamebook_response.body.data.inactive_players_count}
                    - log_gamebook_success:
                        call: sys.log
                        args:
                          text: ${"‚úÖ " + game.matchup + " - Active: " + string(active_players) + ", Inactive: " + string(inactive_players) + " (DNP reasons captured!)"}
                          severity: INFO
                - condition: true
                  steps:
                    - increment_failed_2:
                        assign:
                          - failed_games: ${failed_games + 1}
                          - failed_game_codes: ${list.concat(failed_game_codes, [game.game_code])}
                    - log_gamebook_error:
                        call: sys.log
                        args:
                          text: ${"‚ùå Processing failed for " + game.game_code}
                          severity: WARNING
          
          - increment_total:
              assign:
                - total_games_processed: ${total_games_processed + 1}
          
          # Rate limiting - conservative for NBA.com
          - rate_limit_pause:
              call: sys.sleep
              args:
                seconds: 5  # 5-second delay between games (conservative)
        
    - calculate_final_status:
        assign:
          - workflow_end: ${sys.now()}
          - total_duration: ${workflow_end - workflow_start}
          - success_rate: ${if(total_games_processed > 0, successful_games / total_games_processed * 100, 0)}
        
    - set_overall_status:
        switch:
          - condition: ${successful_games == 0}
            assign:
              - overall_status: "FAILURE"
          - condition: ${failed_games == 0}
            assign:
              - overall_status: "SUCCESS"
          - condition: ${success_rate >= 85}
            assign:
              - overall_status: "SUCCESS_WITH_MINOR_FAILURES"
          - condition: true
            assign:
              - overall_status: "PARTIAL_SUCCESS"
              
    - write_status_to_gcs:
        try:
          steps:
            - prepare_status_data:
                assign:
                  - bucket_name: "nba-props-status"
                  - file_path: ${"workflow-status/collect-nba-gamebooks-external-" + execution_id + ".json"}
                  - status_data:
                      workflow: "collect-nba-gamebooks-external-schedule"
                      execution_id: ${execution_id}
                      execution_time: ${current_timestamp}
                      total_duration: ${total_duration}
                      status: ${overall_status}
                      approach: "external_schedule_extraction"  # MUCH more reliable!
                      pdf_version: ${pdf_version}
                      season: ${season}
                      backfill_summary:
                        total_games_processed: ${total_games_processed}
                        successful_games: ${successful_games}
                        failed_games: ${failed_games}
                        success_rate_percent: ${success_rate}
                        failed_game_codes: ${failed_game_codes}
                        phase: "2A"
                        dnp_reasons_captured: true
                        original_pdfs_saved: true
                        
            - write_to_gcs_native:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket_name}
                  name: ${file_path}
                  uploadType: "media"
                  body: ${json.encode(status_data)}
                  
            - log_status_written:
                call: sys.log
                args:
                  text: "Status written to GCS successfully"
                  severity: INFO
        except:
          as: e
          steps:
            - log_gcs_failure:
                call: sys.log
                args:
                  text: "Failed to write status to GCS"
                  severity: WARNING
            
    - final_log:
        call: sys.log
        args:
          text: ${"üèÜ Phase 2A Complete! " + string(successful_games) + "/" + string(total_games_processed) + " games (" + string(int(success_rate)) + "% success) - DNP reasons captured + PDFs saved!"}
          severity: INFO
          
    - return_summary:
        return:
          status: ${overall_status}
          approach: "external_schedule_extraction"
          pdf_version: ${pdf_version}
          season: ${season}
          total_games_processed: ${total_games_processed}
          successful_games: ${successful_games}
          failed_games: ${failed_games}
          success_rate_percent: ${success_rate}
          failed_game_codes: ${failed_game_codes}
          duration_seconds: ${total_duration}
          timestamp: ${current_timestamp}
          phase: "2A"
          dnp_reasons_captured: true
          original_pdfs_saved: true
